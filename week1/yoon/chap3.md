# 3장 모든 객체의 공통 메서드

Objects는 객체를 만들 수 있는 구체 클래스이지만, 기본적으로 상속하여 사용되도록 설계되어있다.

그 안에 있는 final이 아닌 메서드 (equals. hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계되어 진 것이고 또 그 재정의 할 떄 지켜야하는 일반 규약이 존재한다. 그것을 지키면서 재정의를 해야하고 그렇지 않다면 HashMap이나 HashSet등을 오작동하게 만들 수 있다.

### 3 - 10 equals는 일반 규약을 지켜 재정의하라.

eqauls는 지켜져야하는 규약이 까다롭게 존재한다. 열거한 상황 중 하나에 해당한다면, 재정의 하지 않는 것이 좋다.

- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 “논리적 동치성”을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에서도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메소드를 호출할 일이 없다.

equals 재정의를 해야하는 경우는

객체 식별성(두 객체가 물리적으로 같은가)가 아니라 논리적 동치성을 확인해야하는 데, 논리적 동치성을 비교하도록 재정의가 되지 않았을 때 이다.

물리적으로 같은 가 ( == 연산자로, 값 자체가 같은 지를 판단. 기본 타입일 경우에는 그 값을 가리키지만, 참조 타입인 경우에는 실제 값이 있는 메모리 주소를 가리킴. 그로 인해서 핵심 값이 같아도, 저장되는 메모리 주소가 다르면 false), 논리적 동치서은 정해진 핵심값이 같은 지를 판단.

재정의할 경우에 지켜야하는 일반 규약

- 반사성
    - null이 아닌 모든 참조 값 x에 대한 x.equals(x)는 true이다.
- 대칭성
    - null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true면 y.equals(y)도 true)
- 추이성
    - null이 아닌 모든 참조 값 x, y, z에 대해 x.equlas(y)가 true, y.equals(z)가 true면 x.equals(z)도 true이다.
- 일관성
- null-아님

어기기 쉬운 상황

- 대칭성
    1. 상위 클래스에 없는 필드를 추가한 하위 클래스인 경우

       → 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는 다.


양질의 equals 메소드를 재정의하는 방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지를 확인한다.
2. instanceof 연산자로 입력이 올바른 타입인 지 확인한다.
    1. 정의된 클래스끼리 비교하는 것이 보통이지만, 그 클래스가 구현한 특정 인터페이스가 될수도 있고 그 인터페이스를 구현한 서로 다른 클래스를 비교하는 경우도 있을 수 있기 때문에 타입도 확인한다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 핵심 필드를 모두 일치하는 지 하나씩 검사한다.

주의사항

1. equals를 재정의할 땐 hashCode도 반드시 재정의하자.
2. 너무 복잡하게 해결하지 마라.
3. Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.
4. 꼭 필요한 경우가 아니면 equals를 재정의하지 말자.

### 3- 11 equals를 재정의하려거든 hashCode도 재정의하라.

hashCode의 개요

- hashCode 메서드란 객체를 식별할 수 있는 고유한 정수 값이다.
- 이 값은 객체의 메모리 주소를 기반으로 생성이 된다.
- 동등한 객체( equals()로 비교했을 때 true인 관계)는 같은 hashCode()값을 가져야한다.
- 서로 다른 객체라도 같은 hashCode 값을 가질 수 있다.

hashCode와 equals의 관계

- HashSet, HashMap, Hashtable 등의 자료구조에서는 hashCode 값을 먼저 비교하고 같은 경우에 equals 메소드로 비교를 한다.

hashCode() 메서드 구현 시 고려사항

- 객체의 핵심 필드 값을 활용해서 hashCode() 값을 생성해야한다.
- 생성된 hashCode()의 값은 객체의 상태가 변경될 때 같이 변경되어야 한다.

### 3- 12 toString을 항상 재정의하라

toString의 기본 규약은 “모든 하위 클래스에서 toString을 재정의하라”이다. 그렇기에 toString은 그 객체의 상태를 의미있게 보여줄 수 있도록 변환해야한다.

클래스가 가진 필드값을 toString에서 뽑아서 쓸려고 하지마라. 포멧이 항상 일정한다고 해도 안되고 항상 일정하지 않기 떄문에 영구적으로 api를 그렇게 한다면 곤란해진다. 거기다가 toString으로 뽑고 포멧에 따라서 뽑아야하는 건 번거로운 작업임으로, 각 필드에 접근할 수 있는 제어자를 만들어야 한다.

### 3 - 13 clone 재정의는 주의해서 진행하라

Cloneable 인터페이스안에 clone 메소드가 존재하지 않는 다. Object 클래스에 선언되어 있고 접근 제어자는 protected이다.

- clone의 문제점
    1. 상속 문제
        1. clone은 접근제어자가 protected이기에 접근 가능하게 만들려면 public 메서드로 재정의 해야한다.
    2. 필드 값을 그대로 복사하지만 참조 필드에 대해선 문제가 생긴다.
        1. 참조 필드를 복사해서 새로운 메모리에 할당을 해야하는 데 참조 하는 값을 복사하는 것이기에 원본 객체와 복사된 객체가 동일한 가변 객체에 대한 참조를 공유해서 서로의 값을 해친다.
    3. final 필드는 객체 생성 시 초기화해야한다. clone 메서드는 생성자를 호출 하지 않기에 일관성이 무너진다.

- 주의사항
    1. 가변 객체를 참조하는 필드에 대해서는 깊은 복사를 진행해서 클론된 객체와 원본 객체가 서로 다른 참조 변수를 갖도록 해야한다.
    2. final 필드를 피하는 것이 좋다.
    3. public인 clone 메서드에서는 throws 절을 없애야 한다.
- 추가 정보
    - 배열은 clone 기능을 제대로 사용할 수 있는 유일한 예시이다. 런타임 타입과 컴파일 타임 타입 모두 원본 배열과 똑같은 배열을 반환하기 때문에 Object[] 이런식의 형변환이을 하지 않아도 된다.

### 3 - 14 Comparable을 구현할 지 고려하라.

Comparable 인터페이스의 유일무이한 메서드인 compareTo()는 Objects의 메서드가 아니다.

Objects의 equals랑 비슷해보이지만 2가지 성격이 다르다.

compareTo는 단순한 동치성 비교뿐 아니라 순서까지도 비교할 수 있고, 제네릭하다.

Comparable 클래스를 구현한 클래스들의 인스턴스들은 자연적인 순서가 있다.

이것을 사용하면서 얻을 수 있는 장점은 인스턴스들을 쉽게 정렬하고, 검색하고 비교할 수 있다. 하지만 주의사항으로는 박싱된 기본 타입 클래스가 제공하는 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.