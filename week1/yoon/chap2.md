## 2-1 생성자 대신 정적 팩터리 메서드를 고려하라.

- 객체의 생성을 관리하는 공장이다. 스프링을 배우면서 나왔던 AppConfig의 역할이 이것이였다. 즉  **객체 생성의 역할을 하는 클래스 메서드** 이다. 그래서 외부에서 객체를 매번 new해서 생성하는 것이 아닌, 이 정적 팩토리 메서드를 활용해서 꺼내는 것이다. 이것의 장점은
1. 객체 생성에 대한 목적을 이름에 담을 수 있다.

   그냥 객체를 생성해서, 왜 그것을 생성했고 어떤 객체인 지 알기 어렵다. 하지만 메서드를 통해 생성한다면 그것이 왜 필요한 지 알 수있다.

   ex) new Lotto() vs .createAutoLotto() || . createManuaLotto()

2. 호출할 때마다 새로운 객체를 생성할 필요가 없다.

   이것을 통해 불변 클래스는 인스턴스를 미리 만들어놓거나, 새로 생성한 인스턴스를 캐싱해서 재사용하는 식으로 불필요한 객체 생성을 하지 않아도 된다. 이것은 플라이웨이트 패턴의 효과와 유사핟.

   생성을 결정한다는 것은 객체 생명 주기를 관리,통제할 수 있다는 것으로도 볼 수 있다.

   ### 플라이웨이트 패턴

   하나의 클래스로 만들어진 여러개의 객체가 존재할 때, 그 객체가 엄청나게 많아지면 메모리를 엄청많이 잡게 될 것이다. 그 때 그 객체가 공통으로 적용되는 필드,메서드와 그 객체 하나 하나가 개인적으로 가져야하는 필드, 메서드를 분리 시키고, 개인적으로 가져야하는 객체가 공통적으로 사용되는 객체를 바라보게 함으로써 사용되는 메모리 양을 줄인다.

3.  하위 자료형 객체를 반환할 수 있다.

    이것은 굉장히 대단한 기능이다. 이렇게 하게 된다면 구현체들은 고수준 모듈이 아닌 저수준 모듈, 인터페이스에 의존할 수 있다. 그것이 바로 DIP로써 의존 역전의 원칙으로 인터페이스를 의존할 수 있게 된다. 그래서 각 레벨별로 반환되는 객체에 따라서 3개의 객체를 따로따로 만드는 게 아닌, 그것들이 상속받은 클래스를 반환해서 DIP를 지킬 수 있게 한다.

4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

✱ 캡슐화 지키기.

이것을 이해하기 아주 좋았던 예시로는 DTO와 Entity 변환과정이다.

DTO로 변환시킬 때 new DTO를 하게 된다면, DTO 생성자가 어떻게 이루어져있는 지를 알아야 한다. 하지만 DTO로 변환시키는 메소드가 DTO안에 존재한다면, 그냥 Entity만 주어도 내부를 몰라도 DTO로 변환시킬 수 있다.

정적 팩토리 메서드 네이밍 컨벤션

- from : 하나의 매개 변수를 받아서 객체를 생성
    - Date d = Date.from(instant);
- of : 여러개의 매개변수를 받아서 객체를 생성
    - Date d = Date.of(instant1, instant2);
- valueOf : from과 of의 더 자세한 버전???
- getInstance or instance : 인스턴스를 생성, 이전에 반환했던 것과 동일할 수 있다.
- newInstance or create : 새로운 인스턴스를 생성
- getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용한다??? Type은 팩토리 메서드가 반환할 객체의 타입이다.
    - FileStore fs = Files.getFileStore(path); ???
- newType : newInstance와 같으나, 다른 클래스에 팩토리 메서드를 정의할 때 쓴다. 아하 외부 클래스에 이 팩토리 메서드를 정의할 떄 쓰는 듯하다.

## 2-2 생성자에 매개변수가 많다면 빌더 패턴을 고려하라.

객체를 생성할 떄 매개변수가 많을 경우, 또 특히 매개변수의 타입이 같을 경우에 일반 생성자를 사용하는 것보다 빌더 패턴을 사용하는 것이 더 유리하다.

빌더 패턴의 효과를 최대화 하기위한 매개변수의 개수는 4개이지만 시간이 지날수록 매개변수의 개수는 자연스럽게 늘기때문에, 애초부터 빌더패턴을 사용하는 것이 좋다.

## 2-3 private 생성자나 열거 타입으로 싱글턴임을 보증하라.

싱글톤이란 인스턴스가 오직 하나만을 생성할 수 있는 클래스를 의미한다.

싱글톤일 경우에는 클라이언트가 테스트하기 까따로울 수 있다. 그래서 타입을 인터페이스로 정의한 다음에 그 인터페이스를 구현해서 만든 인터페이스가 아니라면, 싱글턴 인스턴스를 가짜(mock)구현하기 불가능하다.

싱글턴을 만들 경우에는 생성자를 private으로 막은 다음에 public static 멤버로 단 하나의 인스턴스를 제공하게 해야한다. 그것에 대한 방법은 총 2가지로 final 필드를 제공하는 것과, 정적 팩터리 메서드를 pubblic static 멤버로 제공하는 방식이 있다.

이 두가지를 사용한다고 해서 무적이 아니고, 자바 리플렉션인 AccessibleObject.setAccessible을 사용해서 private 생성자를 호출하게 할 수 있다.

이 뿐아니라 class가 아닌 하나의 원소를 갖는 enum으로 대체할 수도있지만, 이 enum외에 다른 클래스를 상속을 할 수 없다는 단점이 있다.

## 2-4 인스턴스화를 막을려거든 private 생성자를 사용하라.

클래스안에 정적 메소드와 정적 필드만을 담은 클래스를 만들고 싶을 떄가 존재한다. 그렇게 된다면 객체 생성을 하지 않는 다. 하지만 직접 생성자 코드를 만들지 않더라도, 컴파일러가 자동으로 기본 생성자를 만들어낸다. 그렇기에 의도치 않게 인스턴스화될 수 있는 클래스가 목격된다.

추상 클래스라고 하여도 마찬가지로 그것을 상속받으면 인스턴스화 할 수 있는 것은 변하지 않기 떄문이다.

그래서 명시적으로 private 생성자를 추가하여 클래스의 인스턴스화를 막아야 한다.

### 2-5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

이것에 대한 내용은 어렵지 않지만 신경쓰지 않은 부분이다.

A가 B라는 자원을 사용할 때 A안에서 B를 직접 생성하고 final로 갖는 다면, B가 다른 것으로 변경 혹은 확장될 때 A 코드도 수정되어야한다. 그렇기에 그러한 필요한 자원은 생성자나, 빌더패턴으로부터 주입을 받아서 사용하는 것이 클래스의 유연성, 재사용성, 테스트 용이성을 높여준다.

클래스 내부에 하나 이상의 자원에 의존하고 그 자원에 따라서 클래스 동작에 영향을 준다면, 싱글톤이나 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.

## 2-6 불필요한 객체 생성을 피하라.

1. 특정 메소드안에서 객체를 생성하는 것이 존재한다면, 그것을 필드에서 한번만 정의하고 그것을 사용하도록 해라. 그렇지 않다면 메소드를 호출할 떄마다 객체를 불필요하게 생성하기 떄문이다.
2. 기본타입을 묶는 오토타입 사용을 자제하자. 오토타입을 사용한다면, 그 값을 새로 정의할 때마다 불필요한 객체가 생성되기 때문이다.

## 2-7 다 쓴 객체 참조를 해제하라.

stack 클래스가 메모리 누수에 취약한 이유는 스택이 자기 메모리를 직접 관리하기 때문이고, 그 스택은 객체 자체가 아닌 객체 참조를 담는 원소의 배열로 저장소 풀을 만들어 관리함. 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않지만, 가비지 컬렉터가 이 사실을 알 수 없다. 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체이다. 일일이 null처리 하지 않고 참조를 담은 변수를 유호 범위 밖으로 밀어내는 것이 정석이지만 스택같은 경우는 안쓰는 객체 참조를 null 처리해서 쓰지 않는 다고 알려야한다.

캐시 역시도 메모리 누수를 일으키는 주범. 이것에 대한 해법은 여러가지가 존재하지만 그 중 하나는 WeakHashMap을 사용하여 캐시를 만든다. 다 쓴 엔트리는 그 즉시 자동으로 제거가 된다.

하지만 이것은 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 경우이고, 언제 그 캐시를 사용할 지 모르는 경우에는 시간이 갈 수록 엔트리의 가치를 떨어뜨리는 방식을 사용해서 가치가 너무 적어지면 청소하는 식으로 해야한다.

3 번째 메모리 누수의 주범은, 리스너 혹은 콜백이다. 콜백을 등록만 하고 명확히 해제하지 않는 다면 콜백은 계속 쌓여만 간다. 이럴 떄 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해간다.

## 2-8 finalizer와 cleaner 사용을 피하라.

finalizer()는 Object class 안에 존재하는 메소드로 gc가 일어나기 전에 수행된다.

gc란 Garbage Collection으로 자바 애플리케이션에서 더이상 쓰지 않는 메모리를 자동 수거하는 것을 의미한다.

이것을 피하는 이유는 이것이 언제 일어날지를 알 수 없고 즉각적으로 실행되지 않고, 실행을 보장할 수 없기 때문이다. 이 메소드의 실행 우선 순위가 굉장히 낮다.

cleaner는 스레드를 명시할 수 있지만 위에 같은 단점을 그대로 가지고 있다.

단점

- 즉시 수행되지 않는다.
- 실행된다는 보장이 없다.
- 동작 중 예외가 발생하면 그 finalizer()나 cleaner의 로직이 무시된다.
- 성능에 문제가 있다.

대안

- 반납할 자원이 있는 클래스는 AutoCloseable을 구현하고 클라이언트에서 close()를 호출한다.
- try-with-resource를 사용해서 자동으로 닫히게 한다.

## 2-7 try-finally보다는 try-with-resources를 사용하라.

finally에서 자원을 닫는 코드를 넣는 것보다는 try( 여기서 자원 할당 )을 하여 객체 생명주기를 활용하여 try문에서만 사용되고 끝나면 해제되도록 유도하라.